<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>MIPS Web Simulator</title>
    <style>
      :root {
        --bg-color: #f5f5f5;
        --container-bg: white;
        --text-color: #333;
        --border-color: #ccc;
        --highlight-color: #ffff99;
        --terminal-bg: #2a2a2a;
        --terminal-text: #fff;
        --status-bg: #f9f9f9;
        --table-header-bg: #f2f2f2;
        --shadow-color: rgba(0, 0, 0, 0.1);
      }

      [data-theme="dark"] {
        --bg-color: #1a1a1a;
        --container-bg: #2a2a2a;
        --text-color: #e0e0e0;
        --border-color: #444;
        --highlight-color: #2c4f7c;
        --terminal-bg: #000;
        --terminal-text: #0f0;
        --status-bg: #333;
        --table-header-bg: #333;
        --shadow-color: rgba(0, 0, 0, 0.3);
      }

      body {
        font-family: Arial, sans-serif;
        margin: 0;
        padding: 20px;
        background-color: var(--bg-color);
        color: var(--text-color);
        transition: background-color 0.3s, color 0.3s;
      }
      .container {
        max-width: 1200px;
        margin: 0 auto;
        background-color: var(--container-bg);
        padding: 20px;
        box-shadow: 0 0 10px var(--shadow-color);
        border-radius: 5px;
        transition: background-color 0.3s, box-shadow 0.3s;
      }
      h1 {
        text-align: center;
        color: var(--text-color);
      }
      .code-container {
        margin-bottom: 50px;
        position: relative;
        display: flex;
        justify-content: center;
      }
      #code-editor {
        width: 100%;
        height: 300px;
        font-family: "Courier New", monospace;
        font-size: 14px;
        padding: 10px;
        border: 1px solid var(--border-color);
        resize: vertical;
        background-color: var(--container-bg);
        color: var(--text-color);
        transition: background-color 0.3s, color 0.3s, border-color 0.3s;
      }
      .controls {
        margin-bottom: 20px;
        display: flex;
        gap: 10px;
      }
      button {
        padding: 8px 15px;
        border: none;
        border-radius: 4px;
        cursor: pointer;
        font-weight: bold;
        transition: background-color 0.3s, color 0.3s;
      }
      #run-button {
        background-color: #4caf50;
        color: white;
      }
      #step-button {
        background-color: #2196f3;
        color: white;
      }
      #reset-button {
        background-color: #f44336;
        color: white;
      }

      .status-container {
        margin-bottom: 20px;
        padding: 10px;
        background-color: var(--status-bg);
        border: 1px solid var(--border-color);
        border-radius: 4px;
        transition: background-color 0.3s, border-color 0.3s;
      }
      /* Terminal styles */
      .terminal {
        font-family: "Courier New", monospace;
        background-color: var(--terminal-bg);
        color: var(--terminal-text);
        padding: 10px;
        border-radius: 4px;
        min-height: 120px;
        display: flex;
        flex-direction: column;
        transition: background-color 0.3s, color 0.3s;
      }

      #terminal-output {
        white-space: pre-wrap;
        word-break: break-word;
        margin-bottom: 5px;
        min-height: 80px;
        overflow-y: auto;
      }

      .terminal-input-container {
        display: flex;
        align-items: center;
        color: var(--terminal-text);
      }

      .terminal-prompt {
        color: #4caf50;
        margin-right: 5px;
        display: none;
      }

      #terminal-input {
        flex: 1;
        background-color: transparent;
        border: none;
        color: var(--terminal-text);
        font-family: "Courier New", monospace;
        font-size: 14px;
        outline: none;
        display: none;
      }

      #terminal-input::placeholder {
        color: rgba(255, 255, 255, 0.5);
      }

      /* Status text */
      #status-text {
        color: var(--text-color);
        margin-top: 10px;
        font-style: italic;
      }

      /* Displays section */
      .displays {
        display: flex;
        gap: 20px;
      }
      .display-container {
        flex: 1;
        border: 1px solid var(--border-color);
        border-radius: 4px;
        padding: 10px;
        max-height: 400px;
        overflow-y: auto;
        background-color: var(--container-bg);
        transition: background-color 0.3s, border-color 0.3s;
      }
      .display-container h3 {
        margin-top: 0;
        padding-bottom: 5px;
        border-bottom: 1px solid var(--border-color);
        color: var(--text-color);
      }
      table {
        width: 100%;
        border-collapse: collapse;
      }
      th,
      td {
        padding: 8px;
        text-align: left;
        border-bottom: 1px solid var(--border-color);
        transition: border-color 0.3s;
      }
      th {
        background-color: var(--table-header-bg);
        transition: background-color 0.3s;
      }
      .highlight {
        background-color: var(--highlight-color);
        transition: background-color 0.3s;
      }
      .theme-toggle-container {
        position: fixed;
        top: 20px;
        right: 20px;
        z-index: 1000;
      }

      .theme-toggle-btn {
        display: flex;
        align-items: center;
        gap: 8px;
        padding: 8px 16px;
        border-radius: 20px;
        border: none;
        background-color: #000000;
        color: #ffffff;
        box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
        cursor: pointer;
        transition: all 0.3s ease;
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto,
          sans-serif;
        font-size: 14px;
        font-weight: 500;
      }

      .theme-toggle-btn:hover {
        transform: translateY(-2px);
        box-shadow: 0 4px 8px rgba(0, 0, 0, 0.15);
      }

      .theme-toggle-btn:active {
        transform: translateY(0);
        box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
      }

      .theme-icon {
        font-size: 16px;
      }

      .theme-text {
        transition: opacity 0.3s ease;
      }

      /* Dark theme styles */
      [data-theme="dark"] .theme-toggle-btn {
        background-color: #ffffff;
        color: #000000;
        box-shadow: 0 2px 5px rgba(255, 255, 255, 0.1);
      }
    </style>
  </head>
  <body>
    <div class="container">
      <div class="theme-toggle-container">
        <button
          id="theme-toggle"
          class="theme-toggle-btn"
          aria-label="Toggle dark/light mode"
        >
          <span class="theme-icon">☀️</span>
        </button>
      </div>

      <h1>MIPS Web Simulator</h1>

      <div class="code-container">
        <textarea id="code-editor">
.data
prompt_initial: .asciiz "Please select from the options above: "
prompt_selection: .asciiz "\n1.Fibonacci | 2.Factorial | 3.Negative/Positive | 4.EXIT \n"
prompt_fib: .asciiz "You have selected: Fibonacci. "
prompt_fact: .asciiz "You have selected: Factorial. "
prompt_nega: .asciiz "You have selected: Negative/Positive. "
prompt_input: .asciiz "Please enter valid integer: "
prompt_result: .asciiz "The result is: "
prompt_negative_true: .asciiz "Negative."
prompt_positive_true: .asciiz "Positive."
prompt_zero_error: .asciiz "INVALID NUMBER."
.text
addi $t1, $zero, 1  # fib
addi $t2, $zero, 2  # fact
addi $t3, $zero, 3  # nega
addi $t4, $zero, 4  # end
j loop

loop:
    ##### PROMPTS PRINTS #####
    li $v0, 4
    la $a0, prompt_selection
    syscall
    la $a0, prompt_initial
    syscall

    ##### READ INPUT #####
    li $v0, 5
    syscall
    add $t0, $v0, $zero

    ##### COMPARISON #####
    beq $t0, $t1, fib
    beq $t0, $t2, fact
    beq $t0, $t3, nega
    beq $t0, $t4, end

results:
    add $a1, $v0, $zero
    li $v0, 4
    la $a0, prompt_result
    syscall
    li $v0, 1
    add $a0, $a1, $zero
    syscall
    j loop

end:
    li $v0, 10
    syscall

fib:
    li $v0, 4
    la $a0, prompt_fib
    syscall
    la $a0, prompt_input
    syscall
    li $v0, 5
    syscall
    add $a0, $v0, $zero
    jal fibonacci
    j results

fibonacci:
    addi $sp, $sp, -12
    sw $ra, 0($sp)
    sw $s0, 4($sp)
    sw $s1, 8($sp)
    add $s0, $a0, $zero
    beq $s0, $zero, result_0
    beq $s0, $t1, result_1
    addi $a0, $s0, -1
    jal fibonacci
    add $s1, $zero, $v0
    addi $a0, $s0, -2
    jal fibonacci
    add $v0, $v0, $s1

exit_fib:
    lw $ra, 0($sp)
    lw $s0, 4($sp)
    lw $s1, 8($sp)
    addi $sp, $sp, 12
    jr $ra

result_0:
    li $v0, 0
    j exit_fib

result_1:
    li $v0, 1
    j exit_fib

fact:
    li $v0, 4
    la $a0, prompt_fact
    syscall
    la $a0, prompt_input
    syscall
    li $v0, 5
    syscall
    add $a0, $v0, $zero
    jal factorial
    j results

factorial:
    addi $sp, $sp, -8
    sw $ra, 4($sp)
    sw $a0, 0($sp)
    slti $t0, $a0, 1
    beq $t0, $zero, exit_fact
    addi $v0, $zero, 1
    addi $sp, $sp, 8
    jr $ra

exit_fact:
    addi $a0, $a0, -1
    jal factorial
    lw $a0, 0($sp)
    lw $ra, 4($sp)
    addi $sp, $sp, 8
    mul $v0, $a0, $v0
    jr $ra

nega:
    li $v0, 4
    la $a0, prompt_nega
    syscall
    la $a0, prompt_input
    syscall
    li $v0, 5
    syscall
    add $a0, $v0, $zero
    beq $a0, $zero, zero_error
    jal negative
    j results

negative:
    slt $a1, $a0, $zero
    beq $a1, $t1, negative_true
    li $v0, 4
    la $a0, prompt_positive_true
    syscall
    j loop

negative_true:
    li $v0, 4
    la $a0, prompt_negative_true
    syscall
    j loop

zero_error:
    li $v0, 4
    la $a0, prompt_zero_error
    syscall
    j loop
</textarea
        >
      </div>

      <div class="controls">
        <button id="run-button">Run All</button>
        <button id="step-button">Step</button>
        <button id="reset-button">Reset</button>
      </div>

      <div class="status-container">
        <div class="terminal">
          <div id="terminal-output"></div>
          <div class="terminal-input-container">
            <span class="terminal-prompt">></span>
            <input
              type="text"
              id="terminal-input"
              placeholder="Enter input here..."
            />
          </div>
        </div>
        <div id="status-text"></div>
      </div>

      <div class="displays">
        <div class="display-container">
          <h3>Registers</h3>
          <div id="registers-container">
            <table id="registers-table">
              <thead>
                <tr>
                  <th>Register</th>
                  <th>Value</th>
                  <th>Hex</th>
                </tr>
              </thead>
              <tbody id="registers-body">
                <!-- Register data will be populated here -->
              </tbody>
            </table>
          </div>
        </div>

        <div class="display-container">
          <h3>Memory</h3>
          <div id="memory-container">
            <table id="memory-table">
              <thead>
                <tr>
                  <th>Address</th>
                  <th>Value</th>
                  <th>Hex</th>
                </tr>
              </thead>
              <tbody id="memory-body">
                <!-- Memory data will be populated here -->
              </tbody>
            </table>
          </div>
        </div>
      </div>
    </div>
    </div>
    <script>
      // MIPS Simulator JavaScript Implementation
      class MIPSSimulator {
        constructor() {
          this.resetSimulator();
          this.setupEventListeners();
          this.updateRegisterDisplay();

          // Make sure the code container has position relative for proper highlighting
          document.querySelector(".code-container").style.position = "relative";
        }

        resetSimulator() {
          // Initialize registers
          this.registers = {
            $zero: 0,
            $at: 0,
            $v0: 0,
            $v1: 0,
            $a0: 0,
            $a1: 0,
            $a2: 0,
            $a3: 0,
            $t0: 0,
            $t1: 0,
            $t2: 0,
            $t3: 0,
            $t4: 0,
            $t5: 0,
            $t6: 0,
            $t7: 0,
            $s0: 0,
            $s1: 0,
            $s2: 0,
            $s3: 0,
            $s4: 0,
            $s5: 0,
            $s6: 0,
            $s7: 0,
            $t8: 0,
            $t9: 0,
            $k0: 0,
            $k1: 0,
            $gp: 0,
            $sp: 0,
            $fp: 0,
            $ra: 0,
            $hi: 0,
            $lo: 0,
            $pc: 0,
          };

          // Initialize memory
          this.memory = {};

          // Initialize symbol table
          this.symbols = {};
          this.memoryAddress = 0x10010000; // Start of data segment

          // Program state
          this.program = [];
          this.currentLine = 0;
          this.labels = {};
          this.executionFinished = false;
          this.highlightedLine = null;
          this.executingLine = null;
          this.inDataSection = false;
          this.inTextSection = false;
          this.globlMain = false;
          this.waitingForInput = false;
          this.inputCallback = null;
          this.terminalOutput = "";

          // Clear terminal output
          this.clearTerminal();
        }

        setupEventListeners() {
          document
            .getElementById("run-button")
            .addEventListener("click", () => this.runProgram());
          document
            .getElementById("step-button")
            .addEventListener("click", () => this.stepProgram());
          document
            .getElementById("reset-button")
            .addEventListener("click", () => this.resetProgram());
          const terminalInput = document.getElementById("terminal-input");
          if (terminalInput) {
            terminalInput.addEventListener("keydown", (e) => {
              if (e.key === "Enter" && this.waitingForInput) {
                const input = terminalInput.value;
                this.handleTerminalInput(input);
                terminalInput.value = "";
                e.preventDefault();
              }
            });
          }

          // Add theme toggle event listener
          document
            .getElementById("theme-toggle")
            .addEventListener("click", () => this.toggleTheme());
        }

        toggleTheme() {
          const currentTheme =
            document.documentElement.getAttribute("data-theme");
          const newTheme = currentTheme === "dark" ? "light" : "dark";
          document.documentElement.setAttribute("data-theme", newTheme);

          // Update the theme toggle button icon and text
          const themeToggle = document.getElementById("theme-toggle");
          const themeIcon = themeToggle.querySelector(".theme-icon");
          const themeText = themeToggle.querySelector(".theme-text");

          if (newTheme === "dark") {
            themeIcon.textContent = "🌙";
            themeText.textContent = "Dark";

            // Update editor highlight colors
            this.clearHighlight();
            if (this.executingLine !== null) {
              this.highlightLine(this.executingLine);
            }

            // Store theme preference
            localStorage.setItem("theme", "dark");
          } else {
            themeIcon.textContent = "☀️";
            themeText.textContent = "Light";

            // Update editor highlight colors
            this.clearHighlight();
            if (this.executingLine !== null) {
              this.highlightLine(this.executingLine);
            }

            // Store theme preference
            localStorage.setItem("theme", "light");
          }
        }
        printToTerminal(text) {
          this.terminalOutput += text;
          const terminalOutput = document.getElementById("terminal-output");
          if (terminalOutput) {
            terminalOutput.textContent = this.terminalOutput;
            // Scroll to bottom when new content is added
            terminalOutput.scrollTop = terminalOutput.scrollHeight;
          }
        }

        clearTerminal() {
          this.terminalOutput = "";
          const terminalOutput = document.getElementById("terminal-output");
          if (terminalOutput) {
            terminalOutput.textContent = "";
          }
        }

        handleTerminalInput(input) {
          if (this.waitingForInput && this.inputCallback) {
            this.printToTerminal(input + "\n");
            this.inputCallback(input);
            this.waitingForInput = false;
            this.inputCallback = null;

            // Re-enable buttons
            document.getElementById("run-button").disabled = false;
            document.getElementById("step-button").disabled = false;

            // Hide prompt
            document.querySelector(".terminal-prompt").style.display = "none";
            document.getElementById("terminal-input").style.display = "none";

            // Continue execution
            this.currentLine++;
            if (this.runningAll) {
              this.runProgram();
            }
          }
        }

        readFromTerminal(callback) {
          this.waitingForInput = true;
          this.inputCallback = callback;

          // Show prompt
          document.querySelector(".terminal-prompt").style.display = "inline";
          const inputElement = document.getElementById("terminal-input");
          inputElement.style.display = "inline";
          inputElement.focus();

          // Disable buttons while waiting for input
          document.getElementById("run-button").disabled = true;
          document.getElementById("step-button").disabled = true;
        }

        setStatus(message) {
          // Don't show "add $t1" messages or similar instruction execution messages
          if (
            message.startsWith("Executing:") ||
            message.startsWith("Executing line") ||
            /Executing.*add.*\$t[0-9]/.test(message)
          ) {
            return;
          }

          const statusElement = document.getElementById("status-text");
          if (statusElement) {
            statusElement.textContent = message;
          }
        }

        runProgram() {
          if (!this.program.length) {
            this.parseProgram();
          }

          if (!this.program.length) {
            return;
          }

          this.runningAll = true;

          try {
            while (
              !this.executionFinished &&
              this.currentLine < this.program.length &&
              !this.waitingForInput
            ) {
              this.executeInstruction();
            }

            if (this.executionFinished) {
              this.setStatus("Program execution completed");
              this.runningAll = false;
              alert("Program execution has finished successfully.");
            } else if (this.waitingForInput) {
              // Program is waiting for input, execution will continue after input
            } else {
              this.setStatus(`Program execution completed`);
              this.runningAll = false;
              alert(`Program execution completed.`);
            }

            this.updateRegisterDisplay();
            this.updateMemoryDisplay();
          } catch (e) {
            this.runningAll = false;
            alert(`Error while running program: ${e.message}`);
            console.error(e);
          }
        }

        parseProgram() {
          const code = document.getElementById("code-editor").value;
          const lines = code.split("\n");
          this.program = [];
          this.labels = {};
          this.lineMap = {};
          this.symbols = {};
          this.memoryAddress = 0x10010000; // Start of data segment
          this.globlMain = false;

          let programLine = 0;
          let inDataSection = false;
          let inTextSection = false;

          // First pass: Parse directives and collect labels
          for (let i = 0; i < lines.length; i++) {
            // Remove comments and trim
            let line = lines[i].replace(/#.*$/, "").trim();

            if (!line) continue;

            // Check for section directives
            if (line.toLowerCase() === ".data") {
              inDataSection = true;
              inTextSection = false;
              continue;
            } else if (line.toLowerCase() === ".text") {
              inDataSection = false;
              inTextSection = true;
              continue;
            } else if (line.toLowerCase() === ".globl main") {
              this.globlMain = true;
              continue;
            }

            // Process data section
            if (inDataSection) {
              const labelMatch = line.match(/^(\w+):\s*(.*)/);
              if (labelMatch) {
                const label = labelMatch[1];
                const directive = labelMatch[2].trim();
                this.processDataDirective(label, directive);
              }
            }
            // Process text section
            else if (inTextSection) {
              // Check for labels
              const labelMatch = line.match(/^(\w+):\s*(.*)/);
              if (labelMatch) {
                const label = labelMatch[1];
                const restOfLine = labelMatch[2].trim();
                this.labels[label] = programLine;

                if (restOfLine) {
                  this.lineMap[programLine] = i;
                  this.program.push(restOfLine);
                  programLine++;
                }
              } else {
                this.lineMap[programLine] = i;
                this.program.push(line);
                programLine++;
              }
            }
          }

          // If .globl main is specified, start execution at main label
          if (this.globlMain && "main" in this.labels) {
            this.currentLine = this.labels["main"];
          }

          if (this.program.length > 0) {
            this.setStatus(`Program loaded successfully`);
            this.updateMemoryDisplay();
          } else {
            this.setStatus(
              "Warning: No valid instructions found in .text section"
            );
          }
        }
        // Replace the existing processDataDirective function with this updated version
        processDataDirective(label, directive) {
          // Save symbol address
          this.symbols[label] = this.memoryAddress;

          const parts = directive.trim().split(/\s+/);
          if (parts.length < 1) return;

          const directiveType = parts[0].toLowerCase();
          const args = parts
            .slice(1)
            .join(" ")
            .split(",")
            .map((arg) => arg.trim());

          switch (directiveType) {
            case ".word":
              // Store words (integers)
              for (const arg of args) {
                const value = parseInt(arg);
                this.memory[this.memoryAddress] = value;
                this.memoryAddress += 4; // Word size is 4 bytes
              }
              break;

            case ".half":
              // Store half words (2 bytes)
              for (const arg of args) {
                const value = parseInt(arg) & 0xffff;
                this.memory[this.memoryAddress] = value;
                this.memoryAddress += 2;
              }
              break;

            case ".byte":
              // Store bytes
              for (const arg of args) {
                const value = parseInt(arg) & 0xff;
                this.memory[this.memoryAddress] = value;
                this.memoryAddress += 1;
              }
              break;

            case ".asciiz":
            case ".ascii":
              // Store string (with or without null terminator)
              let stringContent = "";
              // Extract string between quotes
              const match = directive.match(/\.(asciiz|ascii)\s+"([^"]*)"/);
              if (match) {
                stringContent = match[2];

                // Process escape sequences
                stringContent = this.processEscapeSequences(stringContent);

                // Store each character as a byte
                for (let i = 0; i < stringContent.length; i++) {
                  this.memory[this.memoryAddress] = stringContent.charCodeAt(i);
                  this.memoryAddress++;
                }

                // Add null terminator for asciiz
                if (directiveType === ".asciiz") {
                  this.memory[this.memoryAddress] = 0;
                  this.memoryAddress++;
                }
              }
              break;

            case ".space":
              // Allocate space (in bytes)
              if (args.length > 0) {
                const size = parseInt(args[0]);
                for (let i = 0; i < size; i++) {
                  this.memory[this.memoryAddress] = 0;
                  this.memoryAddress++;
                }
              }
              break;

            default:
              console.warn("Unsupported directive:", directiveType);
          }

          // Make sure memory address is word-aligned for the next label
          if (this.memoryAddress % 4 !== 0) {
            this.memoryAddress += 4 - (this.memoryAddress % 4);
          }
        }

        // Add this new helper method to the MIPSSimulator class
        processEscapeSequences(str) {
          return str
            .replace(/\\n/g, "\n")
            .replace(/\\t/g, "\t")
            .replace(/\\r/g, "\r")
            .replace(/\\0/g, "\0")
            .replace(/\\"/g, '"')
            .replace(/\\'/g, "'")
            .replace(/\\\\/g, "\\");
        }
        highlightLine(lineNumber) {
          const codeEditor = document.getElementById("code-editor");
          const lines = codeEditor.value.split("\n");

          // Don't update status for line execution
          // this.setStatus(`Executing line ${lineNumber + 1}: ${lines[lineNumber].trim()}`);

          // Create a temporary div that will display the highlighted code
          const highlightContainer = document.createElement("div");
          highlightContainer.id = "highlighted-code";
          highlightContainer.style.cssText = `
            position: absolute;
            top: ${codeEditor.offsetTop}px;
            left: ${codeEditor.offsetLeft}px;
            width: ${codeEditor.offsetWidth}px;
            height: ${codeEditor.offsetHeight}px;
            background-color: white;
            overflow: auto;
            font-family: "Courier New", monospace;
            font-size: 14px;
            padding: 10px;
            border: 1px solid #ccc;
            pointer-events: none;
            white-space: pre;
          `;

          // Create highlighted HTML content
          let highlightedContent = "";
          for (let i = 0; i < lines.length; i++) {
            if (i === lineNumber) {
              highlightedContent += `<div id="highlighted-line" class="highlight" style="background-color: #ffff99; padding: 2px 0;">${lines[i]}</div>`;
            } else {
              highlightedContent += `<div>${lines[i]}</div>`;
            }
          }

          highlightContainer.innerHTML = highlightedContent;

          // Remove any existing highlight container
          const existingHighlight = document.getElementById("highlighted-code");
          if (existingHighlight) {
            existingHighlight.remove();
          }

          // Add the highlight container on top of the textarea
          codeEditor.parentNode.appendChild(highlightContainer);

          // Store the currently executing line
          this.executingLine = lineNumber;

          // Center the highlighted line in the viewport
          setTimeout(() => {
            const highlightedLine = document.getElementById("highlighted-line");
            if (highlightedLine) {
              // Calculate position to center the line
              const container = document.getElementById("highlighted-code");
              const lineHeight = highlightedLine.offsetHeight;
              const containerHeight = container.offsetHeight;
              const linePosition = highlightedLine.offsetTop;

              // Set scroll position to center the highlighted line
              container.scrollTop =
                linePosition - containerHeight / 2 + lineHeight / 2;
            }
          }, 0);
        }

        clearHighlight() {
          const existingHighlight = document.getElementById("highlighted-code");
          if (existingHighlight) {
            existingHighlight.remove();
          }
        }

        updateRegisterDisplay() {
          const tbody = document.getElementById("registers-body");
          tbody.innerHTML = "";

          for (const [reg, value] of Object.entries(this.registers)) {
            const hexValue = `0x${(value >>> 0).toString(16).padStart(8, "0")}`;
            const row = document.createElement("tr");

            const regCell = document.createElement("td");
            regCell.textContent = reg;
            row.appendChild(regCell);

            const valCell = document.createElement("td");
            valCell.textContent = value;
            row.appendChild(valCell);

            const hexCell = document.createElement("td");
            hexCell.textContent = hexValue;
            row.appendChild(hexCell);

            tbody.appendChild(row);
          }
        }

        updateMemoryDisplay() {
          const tbody = document.getElementById("memory-body");
          tbody.innerHTML = "";

          // Get addresses and sort them numerically
          const addresses = Object.keys(this.memory)
            .map((addr) => parseInt(addr))
            .sort((a, b) => a - b);

          // Find symbols for addresses if possible
          for (const addr of addresses) {
            const value = this.memory[addr];
            const hexValue = `0x${(value >>> 0).toString(16).padStart(8, "0")}`;

            const row = document.createElement("tr");

            const addrCell = document.createElement("td");
            // Look for symbol name
            let symbolName = "";
            for (const [symbol, symbolAddr] of Object.entries(this.symbols)) {
              if (symbolAddr === addr) {
                symbolName = symbol + ": ";
                break;
              }
            }
            addrCell.textContent = `${symbolName}0x${addr
              .toString(16)
              .padStart(8, "0")}`;
            row.appendChild(addrCell);

            const valCell = document.createElement("td");
            // Display as character if in ASCII range
            if (value >= 32 && value <= 126) {
              valCell.textContent = `${value} ('${String.fromCharCode(
                value
              )}')`;
            } else {
              valCell.textContent = value;
            }
            row.appendChild(valCell);

            const hexCell = document.createElement("td");
            hexCell.textContent = hexValue;
            row.appendChild(hexCell);

            tbody.appendChild(row);
          }
        }

        resetProgram() {
          this.resetSimulator();
          this.clearHighlight();
          this.updateRegisterDisplay();
          this.updateMemoryDisplay();
          this.setStatus("Program reset. Ready to execute.");
        }

        stepProgram() {
          if (!this.program.length) {
            this.parseProgram();
          }

          if (!this.program.length) {
            return;
          }

          if (
            !this.executionFinished &&
            this.currentLine < this.program.length
          ) {
            if (this.currentLine in this.lineMap) {
              this.highlightLine(this.lineMap[this.currentLine]);
            }

            try {
              this.executeInstruction();
              this.updateRegisterDisplay();
              this.updateMemoryDisplay();

              if (this.executionFinished) {
                alert("Program execution has finished successfully.");
              }
            } catch (e) {
              alert(`Error executing instruction: ${e.message}`);
              console.error(e);
            }
          } else {
            this.setStatus("Program execution completed");
            alert("Program execution completed.");
          }
        }

        executeInstruction() {
          if (this.currentLine >= this.program.length) {
            this.executionFinished = true;
            return;
          }

          const instruction = this.program[this.currentLine];
          const parts = instruction.split(/,|\s+/).filter((p) => p.trim());

          if (!parts.length) {
            this.currentLine++;
            return;
          }

          const opcode = parts[0];
          this.executeOpcode(opcode, parts);
        }

        executeOpcode(opcode, parts) {
          let nextLine = this.currentLine + 1;

          // Implement supported instructions
          switch (opcode) {
            case "add":
              if (parts.length >= 4) {
                const [_, rd, rs, rt] = parts;
                this.registers[rd] = this.registers[rs] + this.registers[rt];
              }
              break;

            case "addi":
              if (parts.length >= 4) {
                const [_, rt, rs, imm] = parts;
                this.registers[rt] = this.registers[rs] + parseInt(imm);
              }
              break;

            case "sub":
              if (parts.length >= 4) {
                const [_, rd, rs, rt] = parts;
                this.registers[rd] = this.registers[rs] - this.registers[rt];
              }
              break;

            case "mul":
              if (parts.length >= 4) {
                const [_, rd, rs, rt] = parts;
                const result = this.registers[rs] * this.registers[rt];
                this.registers[rd] = result & 0xffffffff;
              }
              break;

            case "div":
              if (parts.length >= 3) {
                const [_, rs, rt] = parts;
                if (this.registers[rt] !== 0) {
                  this.registers["$lo"] = Math.floor(
                    this.registers[rs] / this.registers[rt]
                  );
                  this.registers["$hi"] =
                    this.registers[rs] % this.registers[rt];
                } else {
                  alert("Division by zero error!");
                }
              }
              break;

            case "mflo":
              if (parts.length >= 2) {
                const [_, rd] = parts;
                this.registers[rd] = this.registers["$lo"];
              }
              break;

            case "mfhi":
              if (parts.length >= 2) {
                const [_, rd] = parts;
                this.registers[rd] = this.registers["$hi"];
              }
              break;

            case "and":
              if (parts.length >= 4) {
                const [_, rd, rs, rt] = parts;
                this.registers[rd] = this.registers[rs] & this.registers[rt];
              }
              break;

            case "andi":
              if (parts.length >= 4) {
                const [_, rt, rs, imm] = parts;
                this.registers[rt] = this.registers[rs] & parseInt(imm);
              }
              break;

            case "or":
              if (parts.length >= 4) {
                const [_, rd, rs, rt] = parts;
                this.registers[rd] = this.registers[rs] | this.registers[rt];
              }
              break;

            case "ori":
              if (parts.length >= 4) {
                const [_, rt, rs, imm] = parts;
                this.registers[rt] = this.registers[rs] | parseInt(imm);
              }
              break;

            case "xor":
              if (parts.length >= 4) {
                const [_, rd, rs, rt] = parts;
                this.registers[rd] = this.registers[rs] ^ this.registers[rt];
              }
              break;

            case "nor":
              if (parts.length >= 4) {
                const [_, rd, rs, rt] = parts;
                this.registers[rd] =
                  ~(this.registers[rs] | this.registers[rt]) & 0xffffffff;
              }
              break;

            case "slt":
              if (parts.length >= 4) {
                const [_, rd, rs, rt] = parts;
                this.registers[rd] =
                  this.registers[rs] < this.registers[rt] ? 1 : 0;
              }
              break;

            case "slti":
              if (parts.length >= 4) {
                const [_, rt, rs, imm] = parts;
                this.registers[rt] = this.registers[rs] < parseInt(imm) ? 1 : 0;
              }
              break;

            case "sll":
              if (parts.length >= 4) {
                const [_, rd, rt, shamt] = parts;
                this.registers[rd] =
                  (this.registers[rt] << parseInt(shamt)) & 0xffffffff;
              }
              break;

            case "srl":
              if (parts.length >= 4) {
                const [_, rd, rt, shamt] = parts;
                this.registers[rd] =
                  (this.registers[rt] >>> parseInt(shamt)) & 0xffffffff;
              }
              break;

            case "sra":
              if (parts.length >= 4) {
                const [_, rd, rt, shamt] = parts;
                this.registers[rd] =
                  (this.registers[rt] >> parseInt(shamt)) & 0xffffffff;
              }
              break;

            case "lui":
              if (parts.length >= 3) {
                const [_, rt, imm] = parts;
                this.registers[rt] = (parseInt(imm) << 16) & 0xffffffff;
              }
              break;

            case "lw":
              if (parts.length >= 3) {
                const [_, rt, memRef] = parts;
                const match = memRef.match(/(-?\d+)\((\$\w+)\)/);
                if (match) {
                  const offset = parseInt(match[1]);
                  const rs = match[2];
                  const addr = this.registers[rs] + offset;
                  this.registers[rt] =
                    addr in this.memory ? this.memory[addr] : 0;
                }
              }
              break;

            case "lh":
              if (parts.length >= 3) {
                const [_, rt, memRef] = parts;
                const match = memRef.match(/(-?\d+)\((\$\w+)\)/);
                if (match) {
                  const offset = parseInt(match[1]);
                  const rs = match[2];
                  const addr = this.registers[rs] + offset;
                  // Read half-word (16 bits) from memory
                  const value =
                    addr in this.memory ? this.memory[addr] & 0xffff : 0;
                  // Sign-extend
                  this.registers[rt] =
                    value & 0x8000 ? value | 0xffff0000 : value;
                }
              }
              break;

            case "lhu":
              if (parts.length >= 3) {
                const [_, rt, memRef] = parts;
                const match = memRef.match(/(-?\d+)\((\$\w+)\)/);
                if (match) {
                  const offset = parseInt(match[1]);
                  const rs = match[2];
                  const addr = this.registers[rs] + offset;
                  // Read half-word (16 bits) from memory without sign-extension
                  this.registers[rt] =
                    addr in this.memory ? this.memory[addr] & 0xffff : 0;
                }
              }
              break;

            case "lb":
              if (parts.length >= 3) {
                const [_, rt, memRef] = parts;
                const match = memRef.match(/(-?\d+)\((\$\w+)\)/);
                if (match) {
                  const offset = parseInt(match[1]);
                  const rs = match[2];
                  const addr = this.registers[rs] + offset;
                  // Read byte (8 bits) from memory
                  const value =
                    addr in this.memory ? this.memory[addr] & 0xff : 0;
                  // Sign-extend
                  this.registers[rt] =
                    value & 0x80 ? value | 0xffffff00 : value;
                }
              }
              break;

            case "lbu":
              if (parts.length >= 3) {
                const [_, rt, memRef] = parts;
                const match = memRef.match(/(-?\d+)\((\$\w+)\)/);
                if (match) {
                  const offset = parseInt(match[1]);
                  const rs = match[2];
                  const addr = this.registers[rs] + offset;
                  // Read byte (8 bits) from memory without sign-extension
                  this.registers[rt] =
                    addr in this.memory ? this.memory[addr] & 0xff : 0;
                }
              }
              break;

            case "sw":
              if (parts.length >= 3) {
                const [_, rt, memRef] = parts;
                const match = memRef.match(/(-?\d+)\((\$\w+)\)/);
                if (match) {
                  const offset = parseInt(match[1]);
                  const rs = match[2];
                  const addr = this.registers[rs] + offset;
                  this.memory[addr] = this.registers[rt];
                }
              }
              break;

            case "sh":
              if (parts.length >= 3) {
                const [_, rt, memRef] = parts;
                const match = memRef.match(/(-?\d+)\((\$\w+)\)/);
                if (match) {
                  const offset = parseInt(match[1]);
                  const rs = match[2];
                  const addr = this.registers[rs] + offset;
                  // Store half-word (16 bits)
                  this.memory[addr] = this.registers[rt] & 0xffff;
                }
              }
              break;

            case "sb":
              if (parts.length >= 3) {
                const [_, rt, memRef] = parts;
                const match = memRef.match(/(-?\d+)\((\$\w+)\)/);
                if (match) {
                  const offset = parseInt(match[1]);
                  const rs = match[2];
                  const addr = this.registers[rs] + offset;
                  // Store byte (8 bits)
                  this.memory[addr] = this.registers[rt] & 0xff;
                }
              }
              break;
            case "beq":
              if (parts.length >= 4) {
                const [_, rs, rt, label] = parts;
                if (this.registers[rs] === this.registers[rt]) {
                  if (label in this.labels) {
                    nextLine = this.labels[label];
                  } else {
                    alert(`Undefined label: ${label}`);
                  }
                }
              }
              break;

            case "bne":
              if (parts.length >= 4) {
                const [_, rs, rt, label] = parts;
                if (this.registers[rs] !== this.registers[rt]) {
                  if (label in this.labels) {
                    nextLine = this.labels[label];
                  } else {
                    alert(`Undefined label: ${label}`);
                  }
                }
              }
              break;

            case "ble":
              if (parts.length >= 4) {
                const [_, rs, rt, label] = parts;
                if (this.registers[rs] <= this.registers[rt]) {
                  if (label in this.labels) {
                    nextLine = this.labels[label];
                  } else {
                    alert(`Undefined label: ${label}`);
                  }
                }
              }
              break;

            case "j":
              if (parts.length >= 2) {
                const [_, label] = parts;
                if (label in this.labels) {
                  nextLine = this.labels[label];
                } else {
                  alert(`Undefined label: ${label}`);
                }
              }
              break;
            case "j":
              if (parts.length >= 2) {
                const [_, label] = parts;
                if (label in this.labels) {
                  nextLine = this.labels[label];
                } else {
                  alert(`Undefined label: ${label}`);
                }
              }
              break;

            // New instruction - Jump and Link
            case "jal":
              if (parts.length >= 2) {
                const [_, label] = parts;
                if (label in this.labels) {
                  // Store return address (next instruction) in $ra
                  this.registers["$ra"] = this.currentLine + 1;
                  nextLine = this.labels[label];
                } else {
                  alert(`Undefined label: ${label}`);
                }
              }
              break;

            // New instruction - Jump Register
            case "jr":
              if (parts.length >= 2) {
                const [_, rs] = parts;
                // Jump to address stored in register
                nextLine = this.registers[rs];
              }
              break;

            // New instruction - Load Address (pseudo-instruction)
            case "la":
              if (parts.length >= 3) {
                const [_, rt, label] = parts;
                if (label in this.symbols) {
                  // Load the memory address of the symbol
                  this.registers[rt] = this.symbols[label];
                } else {
                  alert(`Undefined symbol: ${label}`);
                }
              }
              break;

            // New instruction - Load Immediate (pseudo-instruction)
            case "li":
              if (parts.length >= 3) {
                const [_, rt, imm] = parts;
                // Load immediate value into register
                this.registers[rt] = parseInt(imm) & 0xffffffff;
              }
              break;

            case "syscall":
              const service = this.registers["$v0"];
              switch (service) {
                case 1: // Print Integer
                  const intValue = this.registers["$a0"];
                  this.printToTerminal(intValue.toString());
                  break;

                case 4: // Print String
                  const strAddr = this.registers["$a0"];
                  let str = "";
                  let addr = strAddr;

                  // Read until null terminator
                  while (addr in this.memory && this.memory[addr] !== 0) {
                    str += String.fromCharCode(this.memory[addr]);
                    addr++;
                  }

                  this.printToTerminal(str);
                  break;

                case 5: // Read Integer
                  this.readFromTerminal((input) => {
                    const value = parseInt(input.trim()) || 0;
                    this.registers["$v0"] = value;
                  });
                  return; // Don't increment PC yet - will continue after input

                case 8: // Read String
                  const bufferAddr = this.registers["$a0"];
                  const maxLength = this.registers["$a1"];

                  this.readFromTerminal((input) => {
                    // Store the input string in memory
                    const inputStr = input.substring(0, maxLength - 1); // Leave room for null terminator

                    for (let i = 0; i < inputStr.length; i++) {
                      this.memory[bufferAddr + i] = inputStr.charCodeAt(i);
                    }

                    // Add null terminator
                    this.memory[bufferAddr + inputStr.length] = 0;
                  });
                  return; // Don't increment PC yet - will continue after input

                case 10: // Exit
                  this.executionFinished = true;
                  this.runningAll = false;
                  this.setStatus("Program terminated with syscall exit");
                  alert("Program terminated with syscall exit command.");
                  break;

                case 11: // Print Character
                  const charCode = this.registers["$a0"];
                  this.printToTerminal(String.fromCharCode(charCode));
                  break;

                case 12: // Read Character
                  this.readFromTerminal((input) => {
                    this.registers["$v0"] =
                      input.length > 0 ? input.charCodeAt(0) : 0;
                  });
                  return; // Don't increment PC yet - will continue after input

                default:
                  alert(`Unknown syscall code: ${service}`);
              }
              break;
          }

          this.currentLine = nextLine;
          this.registers["$zero"] = 0; // Ensure $zero is always 0
        }
      }

      // Initialize the simulator when the page loads
      document.addEventListener("DOMContentLoaded", () => {
        const simulator = new MIPSSimulator();
      });
    </script>
  </body>
</html>
